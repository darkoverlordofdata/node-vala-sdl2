/* Sound.c generated by valac 0.34.9, the Vala compiler
 * generated from Sound.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <SDL2/SDL_mixer.h>
#include <SDL2/SDL_rwops.h>
#include <stdlib.h>
#include <string.h>


#define SDX_AUDIO_TYPE_SOUND (sdx_audio_sound_get_type ())
#define SDX_AUDIO_SOUND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SDX_AUDIO_TYPE_SOUND, sdxaudioSound))
#define SDX_AUDIO_SOUND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SDX_AUDIO_TYPE_SOUND, sdxaudioSoundClass))
#define SDX_AUDIO_IS_SOUND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SDX_AUDIO_TYPE_SOUND))
#define SDX_AUDIO_IS_SOUND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SDX_AUDIO_TYPE_SOUND))
#define SDX_AUDIO_SOUND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SDX_AUDIO_TYPE_SOUND, sdxaudioSoundClass))

typedef struct _sdxaudioSound sdxaudioSound;
typedef struct _sdxaudioSoundClass sdxaudioSoundClass;
typedef struct _sdxaudioSoundPrivate sdxaudioSoundPrivate;
#define _Mix_FreeChunk0(var) ((var == NULL) ? NULL : (var = (Mix_FreeChunk (var), NULL)))

#define SDX_FILES_TYPE_FILE_HANDLE (sdx_files_file_handle_get_type ())
#define SDX_FILES_FILE_HANDLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SDX_FILES_TYPE_FILE_HANDLE, sdxfilesFileHandle))
#define SDX_FILES_FILE_HANDLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SDX_FILES_TYPE_FILE_HANDLE, sdxfilesFileHandleClass))
#define SDX_FILES_IS_FILE_HANDLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SDX_FILES_TYPE_FILE_HANDLE))
#define SDX_FILES_IS_FILE_HANDLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SDX_FILES_TYPE_FILE_HANDLE))
#define SDX_FILES_FILE_HANDLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SDX_FILES_TYPE_FILE_HANDLE, sdxfilesFileHandleClass))

typedef struct _sdxfilesFileHandle sdxfilesFileHandle;
typedef struct _sdxfilesFileHandleClass sdxfilesFileHandleClass;

#define SDX_TYPE_FILES (sdx_files_get_type ())
#define SDX_FILES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SDX_TYPE_FILES, sdxFiles))
#define SDX_FILES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SDX_TYPE_FILES, sdxFilesClass))
#define SDX_IS_FILES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SDX_TYPE_FILES))
#define SDX_IS_FILES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SDX_TYPE_FILES))
#define SDX_FILES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SDX_TYPE_FILES, sdxFilesClass))

typedef struct _sdxFiles sdxFiles;
typedef struct _sdxFilesClass sdxFilesClass;

#define SDX_TYPE_FILE_TYPE (sdx_file_type_get_type ())
#define _SDL_FreeRW0(var) ((var == NULL) ? NULL : (var = (SDL_FreeRW (var), NULL)))
#define _g_bytes_unref0(var) ((var == NULL) ? NULL : (var = (g_bytes_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

struct _sdxaudioSound {
	GObject parent_instance;
	sdxaudioSoundPrivate * priv;
	Mix_Chunk* chunk;
};

struct _sdxaudioSoundClass {
	GObjectClass parent_class;
};

typedef enum  {
	SDX_FILE_TYPE_Internal,
	SDX_FILE_TYPE_Resource,
	SDX_FILE_TYPE_External,
	SDX_FILE_TYPE_Absolute,
	SDX_FILE_TYPE_Local
} sdxFileType;


static gpointer sdx_audio_sound_parent_class = NULL;

GType sdx_audio_sound_get_type (void) G_GNUC_CONST;
enum  {
	SDX_AUDIO_SOUND_DUMMY_PROPERTY
};
GType sdx_files_file_handle_get_type (void) G_GNUC_CONST;
sdxaudioSound* sdx_audio_sound_new (sdxfilesFileHandle* file);
sdxaudioSound* sdx_audio_sound_construct (GType object_type, sdxfilesFileHandle* file);
GType sdx_files_get_type (void) G_GNUC_CONST;
sdxFiles* sdx_sdx_get_files (void);
gboolean sdx_files_get_isResource (sdxFiles* self);
GType sdx_file_type_get_type (void) G_GNUC_CONST;
sdxFileType sdx_files_file_handle_getType (sdxfilesFileHandle* self);
GBytes* sdx_files_file_handle_bytes (sdxfilesFileHandle* self);
gchar* sdx_files_file_handle_getPath (sdxfilesFileHandle* self);
void sdx_audio_sound_play (sdxaudioSound* self, gint loops);
static void sdx_audio_sound_finalize (GObject* obj);


sdxaudioSound* sdx_audio_sound_construct (GType object_type, sdxfilesFileHandle* file) {
	sdxaudioSound * self = NULL;
	gboolean _tmp0_ = FALSE;
	sdxFiles* _tmp1_ = NULL;
	sdxFiles* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	g_return_val_if_fail (file != NULL, NULL);
	self = (sdxaudioSound*) g_object_new (object_type, NULL);
	_tmp1_ = sdx_sdx_get_files ();
	_tmp2_ = _tmp1_;
	_tmp3_ = sdx_files_get_isResource (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_) {
		sdxfilesFileHandle* _tmp5_ = NULL;
		sdxFileType _tmp6_ = 0;
		_tmp5_ = file;
		_tmp6_ = sdx_files_file_handle_getType (_tmp5_);
		_tmp0_ = _tmp6_ == SDX_FILE_TYPE_Resource;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		GBytes* ptr = NULL;
		sdxfilesFileHandle* _tmp7_ = NULL;
		GBytes* _tmp8_ = NULL;
		SDL_RWops* rw = NULL;
		GBytes* _tmp9_ = NULL;
		gsize _tmp10_;
		guint8* _tmp11_ = NULL;
		GBytes* _tmp12_ = NULL;
		gsize _tmp13_ = 0UL;
		SDL_RWops* _tmp14_ = NULL;
		SDL_RWops* _tmp15_ = NULL;
		Mix_Chunk* _tmp16_ = NULL;
		_tmp7_ = file;
		_tmp8_ = sdx_files_file_handle_bytes (_tmp7_);
		ptr = _tmp8_;
		_tmp9_ = ptr;
		_tmp11_ = g_bytes_get_data (_tmp9_, &_tmp10_);
		_tmp12_ = ptr;
		_tmp13_ = g_bytes_get_size (_tmp12_);
		_tmp14_ = SDL_RWFromMem ((void*) _tmp11_, (gint) _tmp13_);
		rw = _tmp14_;
		_tmp15_ = rw;
		_tmp16_ = Mix_LoadWAV_RW (_tmp15_, 0);
		_Mix_FreeChunk0 (self->chunk);
		self->chunk = _tmp16_;
		_SDL_FreeRW0 (rw);
		_g_bytes_unref0 (ptr);
	} else {
		sdxfilesFileHandle* _tmp17_ = NULL;
		gchar* _tmp18_ = NULL;
		gchar* _tmp19_ = NULL;
		Mix_Chunk* _tmp20_ = NULL;
		_tmp17_ = file;
		_tmp18_ = sdx_files_file_handle_getPath (_tmp17_);
		_tmp19_ = _tmp18_;
		_tmp20_ = Mix_LoadWAV (_tmp19_);
		_Mix_FreeChunk0 (self->chunk);
		self->chunk = _tmp20_;
		_g_free0 (_tmp19_);
	}
	return self;
}


sdxaudioSound* sdx_audio_sound_new (sdxfilesFileHandle* file) {
	return sdx_audio_sound_construct (SDX_AUDIO_TYPE_SOUND, file);
}


void sdx_audio_sound_play (sdxaudioSound* self, gint loops) {
	Mix_Chunk* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->chunk;
	_tmp1_ = loops;
	Mix_PlayChannel (-1, _tmp0_, _tmp1_);
}


static void sdx_audio_sound_class_init (sdxaudioSoundClass * klass) {
	sdx_audio_sound_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = sdx_audio_sound_finalize;
}


static void sdx_audio_sound_instance_init (sdxaudioSound * self) {
}


static void sdx_audio_sound_finalize (GObject* obj) {
	sdxaudioSound * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SDX_AUDIO_TYPE_SOUND, sdxaudioSound);
	_Mix_FreeChunk0 (self->chunk);
	G_OBJECT_CLASS (sdx_audio_sound_parent_class)->finalize (obj);
}


GType sdx_audio_sound_get_type (void) {
	static volatile gsize sdx_audio_sound_type_id__volatile = 0;
	if (g_once_init_enter (&sdx_audio_sound_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (sdxaudioSoundClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) sdx_audio_sound_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (sdxaudioSound), 0, (GInstanceInitFunc) sdx_audio_sound_instance_init, NULL };
		GType sdx_audio_sound_type_id;
		sdx_audio_sound_type_id = g_type_register_static (G_TYPE_OBJECT, "sdxaudioSound", &g_define_type_info, 0);
		g_once_init_leave (&sdx_audio_sound_type_id__volatile, sdx_audio_sound_type_id);
	}
	return sdx_audio_sound_type_id__volatile;
}



